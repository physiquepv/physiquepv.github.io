<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>√âditeur ‚Äî D/A/M (Entr√©e pour appliquer) ‚Ä¢ Auto-sauvegarde</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#141822; --text:#e7eaf0; --muted:#aab2c0; --accent:#6aa4ff;
      --ok:#2ecc71; --border:#283042; --warn:#f39c12;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial,
      Noto Sans, Ubuntu, Cantarell, sans-serif; background:var(--bg); color:var(--text);
      display:flex; flex-direction:column;
    }
    header{
      padding:14px 16px; border-bottom:1px solid var(--border); display:flex; gap:14px;
      align-items:center; flex-wrap:wrap;
    }
    header h1{font-size:16px; margin:0; font-weight:600}
    header .hint{color:var(--muted)}
    .grid{ flex:1; display:grid; grid-template-columns: 1fr 1fr; gap:12px; padding:12px; min-height:0; }
    .pane{ background:var(--panel); border:1px solid var(--border); border-radius:10px; display:flex; min-height:0; }
    .pane .head{
      padding:10px 12px; border-bottom:1px solid var(--border); display:flex; align-items:center;
      justify-content:space-between; gap:8px;
    }
    .pane .title{font-weight:600}
    .pane .controls{display:flex; align-items:center; gap:8px; color:var(--muted)}
    .pane textarea{
      width:100%; height:100%; flex:1; resize:none; border:0; background:transparent; color:var(--text);
      font:13px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding:12px; outline:none; tab-size:2;
    }
    .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    button, .btn{
      background:#1b2230; color:var(--text); border:1px solid var(--border); padding:8px 10px;
      border-radius:8px; cursor:pointer; font-weight:600;
    }
    button:hover{border-color:#38507a}
    label.inline{display:flex; align-items:center; gap:8px; cursor:pointer; font-size:13px}
    input[type="checkbox"]{width:16px; height:16px}
    .statusbar{
      min-height:36px; display:flex; align-items:center; justify-content:space-between;
      padding:0 12px; border-top:1px solid var(--border); color:var(--muted);
    }
    .statusbar .ok{color:var(--ok)}
    .statusbar .accent{color:var(--accent)}
    .statusbar .warn{color:var(--warn)}
    .hint-sm{font-size:12px; color:var(--muted); padding:6px 12px 12px}
    @media (max-width: 920px){ .grid{grid-template-columns:1fr} }
    code.k{background:#101520; border:1px solid var(--border); padding:0 6px; border-radius:6px}
    .log{ padding:6px 12px; font-size:12px; color:var(--muted); max-height:120px; overflow:auto; border-top:1px solid var(--border); }
  </style>
</head>
<body>
  <header>
    <h1>√âditeur D/A/M ‚Äî Entr√©e pour appliquer</h1>
    <div class="hint">Entr√©e = appliquer ‚Ä¢ Shift+Entr√©e = nouvelle ligne ‚Ä¢ Auto-sauvegarde</div>
  </header>

  <div class="grid">
    <!-- Panneau gauche: HTML source -->
    <section class="pane" aria-label="Texte HTML">
      <div style="display:flex; flex-direction:column; width:100%; min-height:0;">
        <div class="head">
          <div class="title">Texte de gauche (HTML ou texte brut)</div>
          <div class="controls row">
            <button id="btnClearLeft" title="Vider le texte de gauche">Vider</button>
          </div>
        </div>
        <textarea id="source" placeholder="Collez ici votre HTML / texte."></textarea>
      </div>
    </section>

    <!-- Panneau droit: r√®gles D/A/M -->
    <section class="pane" aria-label="R√®gles D/A/M">
      <div style="display:flex; flex-direction:column; width:100%; min-height:0;">
        <div class="head">
          <div class="title">R√®gles (D = supprimer ‚Ä¢ A = ajouter ‚Ä¢ M = modifier)</div>
          <div class="controls row">
            <label class="inline" title="Si coch√©: appliquer √† toutes les occurrences (D et M)">
              <input type="checkbox" id="replaceAll" checked />
              <span>Tout remplacer/supprimer</span>
            </label>
            <button id="btnApply" title="Appliquer (Entr√©e)">Appliquer</button>
            <button id="btnUndo" title="Annuler la derni√®re application (Ctrl+Z)">‚Ü©Ô∏è Retour</button>
            <button id="btnClearRight" title="Vider les r√®gles">Vider r√®gles</button>
          </div>
        </div>

        <textarea id="mapping" placeholder="FORMAT STRICT (accepte les cha√Ænes multi-lignes entre quotes):
1) SUPPRESSION
D: &quot;code exact √† supprimer (peut √™tre multi-ligne)&quot;

2) AJOUT
A: &quot;nouveau code (multi-ligne autoris√©)&quot;
Apr√®s: &quot;ancre exacte existante dans le code (peut √™tre multi-ligne)&quot;
OU
A: &quot;nouveau code (multi-ligne autoris√©)&quot;
Avant: &quot;ancre exacte existante dans le code (peut √™tre multi-ligne)&quot;

3) MODIFICATION
M: &quot;code actuel √† remplacer (multi-ligne autoris√©)&quot;
&quot;nouveau code qui le remplace (multi-ligne autoris√©)&quot;

R√®gles:
‚Ä¢ Les guillemets '...' ou &quot;...&quot; sont obligatoires autour du code/texte.
‚Ä¢ Les correspondances sont litt√©rales: ESPACES, TAB, RETOURS LIGNE doivent correspondre exactement.
‚Ä¢ A (Ajout) n'est pas affect√© par l'option ¬´ Tout remplacer/supprimer ¬ª.
‚Ä¢ Si l‚Äôancre de A n‚Äôest pas trouv√©e: insertion en fin de texte (avec alerte).
‚Ä¢ Si l‚Äôancre appara√Æt plusieurs fois: la premi√®re occurrence est utilis√©e.
‚Ä¢ Vous pouvez mettre des commentaires/libres: toute ligne ne commen√ßant pas par D:, A:, M:, Avant:, Apr√®s: est ignor√©e.

Exemples:
D: &quot;let volumeSeries = null;&quot;

A: &quot;&lt;button class='action-btn' id='reset'&gt;üóëÔ∏è Reset&lt;/button&gt;&quot;
Apr√®s: &quot;&lt;button class='action-btn' id='refresh'&gt;üîÑ Actualiser&lt;/button&gt;&quot;

M: &quot;üìä BTC/EUR Trading Chart&quot;
&quot;üìä BTC/USD Trading Chart&quot;"></textarea>

        <div class="hint-sm">
          Notes:
          <br>‚Äî Les op√©rations s‚Äôappliquent dans l‚Äôordre d‚Äô√©criture.
          <br>‚Äî ¬´ Tout remplacer/supprimer ¬ª impacte D et M uniquement (A n‚Äôest pas concern√©).
          <br>‚Äî Les s√©quences \n, \t, \r et les guillemets √©chapp√©s (\", ') sont prises en charge.
        </div>
        <div id="log" class="log" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <div class="statusbar">
    <div id="status">Pr√™t. Tapez vos r√®gles, puis Entr√©e pour appliquer.</div>
    <div><span>Auto-sauvegarde: </span><span id="saved" class="ok">‚úì</span></div>
  </div>

  <script>
    (function(){
      const LS = {
        source: 'fr.dam.html.source.v3',
        mapping: 'fr.dam.html.mapping.v3',
        replaceAll: 'fr.dam.html.replaceAll.v3',
      };

      const $ = (sel)=>document.querySelector(sel);
      const sourceEl = $('#source');
      const mappingEl = $('#mapping');
      const replaceAllEl = $('#replaceAll');
      const statusEl = $('#status');
      const savedEl = $('#saved');
      const btnApply = $('#btnApply');
      const btnUndo = $('#btnUndo');
      const btnClearLeft = $('#btnClearLeft');
      const btnClearRight = $('#btnClearRight');
      const logEl = $('#log');

      // Undo stack (dernier √©tat avant Apply)
      const history = [];
      const HISTORY_LIMIT = 30;

      // Restore
      try {
        const s = localStorage.getItem(LS.source);
        if (s !== null) sourceEl.value = s;
        const m = localStorage.getItem(LS.mapping);
        if (m !== null) mappingEl.value = m;
        const ra = localStorage.getItem(LS.replaceAll);
        if (ra !== null) replaceAllEl.checked = ra === '1';
      } catch(e){
        console.warn('LocalStorage restore error', e);
      }

      // Debounce
      function debounce(fn, ms){
        let t;
        return (...args)=>{
          clearTimeout(t);
          t = setTimeout(()=>fn(...args), ms);
        };
      }

      function saveAll(){
        try {
          localStorage.setItem(LS.source, sourceEl.value);
          localStorage.setItem(LS.mapping, mappingEl.value);
          localStorage.setItem(LS.replaceAll, replaceAllEl.checked ? '1' : '0');
          savedEl.textContent = '‚úì';
          savedEl.className = 'ok';
        } catch(e){
          savedEl.textContent = '‚ö†';
          savedEl.className = 'warn';
          console.warn('LocalStorage save error', e);
        }
      }
      const saveAllDebounced = debounce(saveAll, 200);

      sourceEl.addEventListener('input', saveAllDebounced);
      mappingEl.addEventListener('input', saveAllDebounced);
      replaceAllEl.addEventListener('change', saveAll);

      // Entr√©e (appliquer) vs Shift+Entr√©e (newline)
      mappingEl.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey){
          e.preventDefault();
          applyRules();
        }
      });
      btnApply.addEventListener('click', applyRules);

      btnUndo.addEventListener('click', undoLast);
      // Ctrl/Cmd+Z global (n'interf√®re pas avec les textareas)
      document.addEventListener('keydown', (e)=>{
        const isCtrlZ = (e.key.toLowerCase() === 'z' && (e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey);
        const active = document.activeElement;
        const isTextarea = active && active.tagName === 'TEXTAREA';
        if (isCtrlZ && !isTextarea){
          e.preventDefault();
          undoLast();
        }
      });

      btnClearLeft.addEventListener('click', ()=>{
        if (sourceEl.value && !confirm('Vider le texte de gauche ?')) return;
        sourceEl.value = '';
        saveAll();
        flash('Texte de gauche vid√©.');
      });
      btnClearRight.addEventListener('click', ()=>{
        if (mappingEl.value && !confirm('Vider les r√®gles ?')) return;
        mappingEl.value = '';
        saveAll();
        flash('R√®gles vid√©es.');
      });

      function flash(msg){ statusEl.textContent = msg; }
      function logLine(s){ logEl.textContent += (logEl.textContent ? '\n' : '') + s; logEl.scrollTop = logEl.scrollHeight; }
      function clearLog(){ logEl.textContent = ''; }

      function detectEOL(s){ return /\r\n/.test(s) ? '\r\n' : '\n'; }

      function decodeEscapes(s){
        return String(s || '')
          .replace(/\\n/g, '\n')
          .replace(/\\r/g, '\r')
          .replace(/\\t/g, '\t')
          .replace(/\\"/g, '"')
          .replace(/\\'/g, "'");
      }

      // Lecture d'une cha√Æne entre quotes, potentiellement multi-ligne.
      // Retourne { value, endLineIndex, endOffset, consumedLines }
      function readQuoted(lines, startLineIndex, startOffset){
        let line = lines[startLineIndex];
        if (line == null) return null;

        // sauter espaces
        let i = startOffset | 0;
        while (i < line.length && /\s/.test(line[i])) i++;
        const ch = line[i];
        if (ch !== '"' && ch !== "'"){
          // Non quoted: lire le reste de la ligne (fallback)
          const rest = line.slice(i).trim();
          return { value: decodeEscapes(rest), endLineIndex: startLineIndex, endOffset: line.length, consumedLines: 1 };
        }

        const quote = ch;
        let val = '';
        let escaped = false;
        let li = startLineIndex;
        let pos = i + 1;

        for (; li < lines.length; li++){
          const cur = lines[li];
          for (let j = pos; j < cur.length; j++){
            const c = cur[j];
            if (escaped){
              val += c;
              escaped = false;
            } else if (c === '\\'){
              escaped = true;
            } else if (c === quote){
              // fin de la cha√Æne
              return {
                value: decodeEscapes(val),
                endLineIndex: li,
                endOffset: j + 1,
                consumedLines: li - startLineIndex + 1
              };
            } else {
              val += c;
            }
          }
          // fin de ligne sans fermeture: ajouter un \n
          val += '\n';
          pos = 0;
        }
        // pas de fermeture -> prend tout
        return {
          value: decodeEscapes(val),
          endLineIndex: lines.length - 1,
          endOffset: (lines[lines.length - 1] || '').length,
          consumedLines: lines.length - startLineIndex
        };
      }

      function parseRules(text){
        const lines = String(text || '').replace(/\r\n/g, '\n').split('\n');
        const rules = [];
        let i = 0;

        function peek(idx){ return (lines[idx] || '').trim(); }

        while (i < lines.length){
          const raw = lines[i];
          const line = raw.trim();
          if (!line || line.startsWith('#')){ i++; continue; }

          // D:
          let m = line.match(/^D\s*:\s*(.*)$/i);
          if (m){
            const rq = readQuoted(lines, i, raw.indexOf(m[1]));
            if (rq && rq.value !== undefined){
              rules.push({ type:'D', value: rq.value });
              i = rq.endLineIndex + 1;
              continue;
            } else { i++; continue; }
          }

          // M:
          m = line.match(/^M\s*:\s*(.*)$/i);
          if (m){
            const rFind = readQuoted(lines, i, raw.indexOf(m[1]));
            let replaceVal = '';
            let endIndex = rFind ? rFind.endLineIndex : i;

            // Cherche ligne suivante valable comme rempla√ßant
            let j = (rFind ? rFind.endLineIndex : i) + 1;
            while (j < lines.length){
              const nextRaw = lines[j];
              const next = nextRaw.trim();
              if (!next){ j++; continue; }
              // Stop si c'est le d√©but d'une nouvelle r√®gle
              if (/^(D|A|M)\s*:/i.test(next) || /^Avant\s*:/i.test(next) || /^Apr(?:e|√®)s\s*:/i.test(next)) break;
              const rRep = readQuoted(lines, j, nextRaw.indexOf(next));
              if (rRep){
                replaceVal = rRep.value ?? '';
                endIndex = rRep.endLineIndex;
              }
              j = endIndex + 1;
              break;
            }

            rules.push({
              type:'M',
              find: rFind ? rFind.value || '' : '',
              replace: replaceVal
            });
            i = endIndex + 1;
            continue;
          }

          // A:
          m = line.match(/^A\s*:\s*(.*)$/i);
          if (m){
            const rContent = readQuoted(lines, i, raw.indexOf(m[1]));
            let afterText = null, beforeText = null;
            let endIndex = rContent ? rContent.endLineIndex : i;

            let j = endIndex + 1;
            while (j < lines.length){
              const nextRaw = lines[j];
              const next = nextRaw.trim();
              if (!next){ j++; continue; }

              let ma = next.match(/^Apr(?:e|√®)s\s*:\s*(.*)$/i);
              if (ma){
                const rA = readQuoted(lines, j, nextRaw.indexOf(ma[1]));
                if (rA && rA.value) afterText = rA.value;
                endIndex = rA ? rA.endLineIndex : j;
                j = endIndex + 1;
                continue;
              }
              let mb = next.match(/^Avant\s*:\s*(.*)$/i);
              if (mb){
                const rB = readQuoted(lines, j, nextRaw.indexOf(mb[1]));
                if (rB && rB.value) beforeText = rB.value;
                endIndex = rB ? rB.endLineIndex : j;
                j = endIndex + 1;
                continue;
              }
              // autre chose => stop
              break;
            }
            rules.push({
              type:'A',
              value: rContent ? rContent.value ?? '' : '',
              afterText,
              beforeText
            });
            i = endIndex + 1;
            continue;
          }

          // Lignes libres ignor√©es
          i++;
        }

        return rules;
      }

      function findLineBoundariesAfter(txt, idxEnd, eol){
        // insert apr√®s la fin de la ligne contenant l'ancre
        const nextEol = txt.indexOf(eol, idxEnd);
        return nextEol === -1 ? txt.length : nextEol + eol.length;
      }
      function findLineBoundariesBefore(txt, idxStart, eol){
        // insert au d√©but de la ligne contenant l'ancre
        const prevEol = txt.lastIndexOf(eol, idxStart - 1);
        return prevEol === -1 ? 0 : prevEol + eol.length;
      }

      function undoLast(){
        if (!history.length){
          flash('Rien √† annuler.');
          return;
        }
        const last = history.pop();
        sourceEl.value = last;
        saveAll();
        flash('Annul√© (retour √† l‚Äô√©tat pr√©c√©dent).');
      }

      function applyRules(){
        const rules = parseRules(mappingEl.value);
        if (!rules.length){
          flash('Aucune r√®gle D/A/M d√©tect√©e.');
          return;
        }

        // Sauvegarde dans l'historique (Undo)
        if (history.length >= HISTORY_LIMIT) history.shift();
        history.push(sourceEl.value);

        let txt = sourceEl.value;
        const eol = detectEOL(txt);
        const replaceAll = replaceAllEl.checked;

        let countD = 0, countM = 0;
        let countABlocks = 0, countALines = 0;
        const warnings = [];

        for (const r of rules){
          if (r.type === 'D'){
            const find = r.value ?? '';
            if (!find) continue;
            if (replaceAll){
              const parts = txt.split(find);
              const c = parts.length - 1;
              if (c > 0){
                txt = parts.join('');
                countD += c;
              }
            } else {
              const idx = txt.indexOf(find);
              if (idx !== -1){
                txt = txt.slice(0, idx) + txt.slice(idx + find.length);
                countD += 1;
              }
            }
          } else if (r.type === 'M'){
            const find = r.find || '';
            const repl = r.replace || '';
            if (!find) continue;
            if (replaceAll){
              const parts = txt.split(find);
              const c = parts.length - 1;
              if (c > 0){
                txt = parts.join(repl);
                countM += c;
              }
            } else {
              const idx = txt.indexOf(find);
              if (idx !== -1){
                txt = txt.slice(0, idx) + repl + txt.slice(idx + find.length);
                countM += 1;
              }
            }
          } else if (r.type === 'A'){
            const content = r.value ?? '';
            if (content === '') continue;

            let insertAt = txt.length; // d√©faut: fin
            let anchorFound = false;

            if (r.afterText){
              const idx = txt.indexOf(r.afterText);
              if (idx !== -1){
                insertAt = findLineBoundariesAfter(txt, idx + r.afterText.length, eol);
                anchorFound = true;
              }
            } else if (r.beforeText){
              const idx = txt.indexOf(r.beforeText);
              if (idx !== -1){
                insertAt = findLineBoundariesBefore(txt, idx, eol);
                anchorFound = true;
              }
            }

            if (!anchorFound && (r.afterText || r.beforeText)){
              warnings.push('Ancre introuvable pour un ajout ‚Äî insertion en fin de texte.');
            }

            // Ins√©rer en respectant l'EOL
            const contentNormalized = String(content).replace(/\r\n/g, '\n').split('\n').join(eol);
            const linesInserted = contentNormalized.split(eol).length;
            txt = txt.slice(0, insertAt) + contentNormalized + eol + txt.slice(insertAt);
            countABlocks += 1;
            countALines += linesInserted;
          }
        }

        sourceEl.value = txt;
        saveAll();

        clearLog();
        warnings.forEach(w=>logLine('‚ö† ' + w));

        const parts = [];
        parts.push(`D: ${countD} suppression(s)`);
        parts.push(`M: ${countM} remplacement(s)`);
        parts.push(`A: ${countABlocks} bloc(s), ${countALines} ligne(s) ins√©r√©es`);
        flash('Fait ‚Äî ' + parts.join(' ‚Ä¢ '));
      }

      flash('Pr√™t. Tapez vos r√®gles, puis Entr√©e pour appliquer.');
    })();
  </script>
</body>
</html>
