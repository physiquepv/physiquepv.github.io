<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Patcher IA</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            overflow: hidden;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4ec9b0;
            font-size: 24px;
        }
        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        .panel {
            background: #252526;
            border-radius: 6px;
            padding: 8px;
            border: 1px solid #3e3e42;
        }
        .panel h2 {
            color: #569cd6;
            margin-bottom: 5px;
            font-size: 14px;
        }
        textarea {
            width: 100%;
            height: 180px;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        button {
            display: block;
            width: 100%;
            max-width: 250px;
            margin: 8px auto;
            padding: 10px 20px;
            background: #4ec9b0;
            color: #000;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            background: #6ee7d2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 201, 176, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 5px 0;
        }
        .undo-btn {
            background: #ce9178;
            max-width: 200px;
        }
        .undo-btn:hover {
            background: #dea485;
        }
        .undo-btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .preview-btn {
            background: #569cd6;
            max-width: 200px;
        }
        .preview-btn:hover {
            background: #7bb3e6;
        }
        .preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            z-index: 1000;
            padding: 20px;
        }
        .preview-container.active {
            display: flex;
            flex-direction: column;
        }
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .preview-header h3 {
            color: #4ec9b0;
            margin: 0;
        }
        .close-preview {
            background: #f44242;
            padding: 10px 20px;
            max-width: 150px;
            margin: 0;
        }
        .close-preview:hover {
            background: #ff5555;
        }
        .preview-frame {
            flex: 1;
            background: white;
            border: 3px solid #4ec9b0;
            border-radius: 8px;
            overflow: auto;
        }
        .status {
            text-align: center;
            padding: 6px;
            margin: 5px 0;
            border-radius: 4px;
            display: none;
            font-size: 13px;
        }
        .status.success {
            background: #4ec9b033;
            border: 1px solid #4ec9b0;
            color: #4ec9b0;
            display: block;
        }
        .status.error {
            background: #f4424233;
            border: 1px solid #f44242;
            color: #f44242;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ Auto-Patcher IA</h1>
        
        <div class="panels">
            <div class="panel">
                <h2>üìÑ Ton code HTML actuel</h2>
                <textarea id="originalCode" placeholder="Colle ton code HTML ici..."></textarea>
            </div>
            
            <div class="panel">
                <h2>ü§ñ Instructions JSON de l'IA</h2>
                <textarea id="aiInstructions" placeholder='Colle la r√©ponse JSON de l\'IA ici...

Exemple :
{
  "changes": [
    {
      "action": "replace",
      "search": "<h1>Ancien</h1>",
      "replace": "<h1>Nouveau</h1>"
    }
  ]
}'></textarea>
            </div>
        </div>

        <button onclick="applyChanges()">‚ú® Appliquer les changements</button>
        
        <div class="button-group">
            <button class="undo-btn" id="undoBtn" onclick="undo()" disabled>‚Ü∂ Annuler (Ctrl+Z)</button>
            <button class="preview-btn" onclick="openPreview()">üëÅÔ∏è Pr√©visualiser</button>
        </div>
        
        <div id="status" class="status"></div>

    </div>

    <div class="preview-container" id="previewContainer">
        <div class="preview-header">
            <h3>üëÅÔ∏è Pr√©visualisation du code modifi√©</h3>
            <button class="close-preview" onclick="closePreview()">‚úï Fermer</button>
        </div>
        <iframe class="preview-frame" id="previewFrame"></iframe>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const history = [];
        const cache = {};
        
        // Sauvegarder dans localStorage
        function saveToStorage() {
            localStorage.setItem('originalCode', cache.originalCode.value);
            localStorage.setItem('aiInstructions', cache.aiInstructions.value);
        }
        
        // Charger depuis localStorage
        function loadFromStorage() {
            const savedCode = localStorage.getItem('originalCode');
            const savedInstructions = localStorage.getItem('aiInstructions');
            
            cache.originalCode.value = savedCode || `<!DOCTYPE html>\n<html>\n<head>\n    <title>Mon Site</title>\n</head>\n<body>\n    <h1>Ancien Titre</h1>\n    <p>Contenu de test</p>\n</body>\n</html>`;
            cache.aiInstructions.value = savedInstructions || `{\n  "changes": [\n    {\n      "action": "replace",\n      "search": "<h1>Ancien Titre</h1>",\n      "replace": "<h1>Nouveau Titre Modifi√© ‚ú®</h1>"\n    }\n  ]\n}`;
        }
        
        window.addEventListener('load', () => {
            cache.originalCode = $('originalCode');
            cache.aiInstructions = $('aiInstructions');
            cache.status = $('status');
            cache.undoBtn = $('undoBtn');
            cache.previewContainer = $('previewContainer');
            cache.previewFrame = $('previewFrame');
            
            loadFromStorage();
            
            // Auto-save au changement
            cache.originalCode.addEventListener('input', saveToStorage);
            cache.aiInstructions.addEventListener('input', saveToStorage);
        });
        
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.key === 'Escape') {
                closePreview();
            }
        });

        function applyChanges() {
            cache.status.className = 'status';
            
            const original = cache.originalCode.value;
            const instructions = cache.aiInstructions.value;

            if (!original.trim()) return showStatus('error', '‚ùå Veuillez entrer du code HTML');
            if (!instructions.trim()) return showStatus('error', '‚ùå Veuillez entrer les instructions de l\'IA');

            history.push(original);
            cache.undoBtn.disabled = false;

            try {
                const changes = parseInstructions(instructions);
                if (!Array.isArray(changes) || !changes.length) {
                    throw new Error('Aucun changement d√©tect√©');
                }

                let code = original;
                let count = 0;

                for (const change of changes) {
                    const act = change.action || 'replace';
                    const s = change.search;
                    const r = change.replace;
                    const ins = change.insert;

                    if (act === 'replace') {
                        if (typeof s !== 'string') throw new Error('search doit √™tre une cha√Æne');

                        const before = code;

                        // 1) essai strict
                        if (code.includes(s)) {
                            code = code.replace(s, r ?? '');
                        } else {
                            // 2) essai souple multi-ligne
                            const re = buildFlexibleRegexFrom(s);
                            if (re && re.test(code)) {
                                code = code.replace(re, () => r ?? '');
                            }
                        }

                        if (code !== before) count++;

                    } else if (act === 'insert_after' && s !== undefined) {
                        if (code.includes(s)) {
                            code = code.replace(s, s + (ins ?? ''));
                            count++;
                        } else {
                            const re = buildFlexibleRegexFrom(s);
                            if (re && re.test(code)) {
                                code = code.replace(re, (m) => m + (ins ?? ''));
                                count++;
                            }
                        }
                    } else if (act === 'insert_before' && s !== undefined) {
                        if (code.includes(s)) {
                            code = code.replace(s, (ins ?? '') + s);
                            count++;
                        } else {
                            const re = buildFlexibleRegexFrom(s);
                            if (re && re.test(code)) {
                                code = code.replace(re, (m) => (ins ?? '') + m);
                                count++;
                            }
                        }
                    } else if (act === 'delete' && s !== undefined) {
                        if (code.includes(s)) {
                            code = code.replace(s, '');
                            count++;
                        } else {
                            const re = buildFlexibleRegexFrom(s);
                            if (re && re.test(code)) {
                                code = code.replace(re, '');
                                count++;
                            }
                        }
                    }
                }

                cache.originalCode.value = code;
                saveToStorage();
                showStatus('success', `‚úÖ ${count} changement(s) appliqu√©(s)`);
            } catch (error) {
                showStatus('error', `‚ùå ${error.message}`);
            }
        }

        function undo() {
            if (!history.length) return;
            cache.originalCode.value = history.pop();
            saveToStorage();
            cache.undoBtn.disabled = !history.length;
            showStatus('success', '‚Ü∂ Changement annul√©');
        }

        function openPreview() {
            const code = cache.originalCode.value;
            if (!code.trim()) return showStatus('error', '‚ùå Aucun code √† pr√©visualiser');
            
            cache.previewContainer.classList.add('active');
            cache.previewFrame.src = URL.createObjectURL(new Blob([code], { type: 'text/html' }));
        }

        function closePreview() {
            cache.previewContainer.classList.remove('active');
            cache.previewFrame.src = '';
        }

        // --- Parsing Instr. ---

        function parseInstructions(instructionsText) {
            // 1) Essaye le JSON d‚Äôabord
            try {
                const obj = JSON.parse(instructionsText);
                if (obj && Array.isArray(obj.changes)) return obj.changes;
            } catch (e) {
                // pas du JSON, on tente Avant/Apr√®s
            }

            // 2) Sinon, essaye le format Avant/Apr√®s
            const pairs = parseAvantApresFormat(instructionsText);
            if (!pairs.length) {
                throw new Error("Format d‚Äôinstructions non reconnu. Fournis un JSON valide ou un bloc ‚ÄúAvant/Apr√®s‚Äù.");
            }
            // Convertit en ‚Äúchanges‚Äù pour l‚Äôex√©cuteur existant
            return pairs.map(({ before, after }) => ({
                action: 'replace',
                search: before,
                replace: after
            }));
        }

        function parseAvantApresFormat(text) {
            const res = [];
            const avantRe = /^[ \t]*Avant(?:\s*[:\-‚Äî])?\s*$/mi;
            const apresRe = /^[ \t]*Apr(?:e|√®)s(?:\s*[:\-‚Äî])?\s*$/mi;

            let pos = 0;
            while (true) {
                const avantPos = findMarkerIndex(text, avantRe, pos);
                if (avantPos === -1) break;

                const avantStartCode = nextLineStart(text, avantPos);
                const apresPos = findMarkerIndex(text, apresRe, avantStartCode);
                if (apresPos === -1) break;

                const apresStartCode = nextLineStart(text, apresPos);
                const nextAvantPos = findMarkerIndex(text, avantRe, apresStartCode);

                const avantSeg = text.slice(avantStartCode, apresPos);
                const apresSeg = text.slice(apresStartCode, nextAvantPos === -1 ? text.length : nextAvantPos);

                const before = extractCodeFromSegment(avantSeg);
                const after = extractCodeFromSegment(apresSeg);

                if (before && after) {
                    res.push({ before, after });
                }

                pos = nextAvantPos === -1 ? text.length : nextAvantPos;
            }
            return res;
        }

        function findMarkerIndex(text, regex, fromIndex) {
            const sub = text.slice(fromIndex);
            const re = new RegExp(regex.source, regex.flags);
            const m = re.exec(sub);
            return m ? fromIndex + m.index : -1;
        }

        function nextLineStart(text, index) {
            const nl = text.indexOf('\n', index);
            return nl === -1 ? text.length : nl + 1;
        }

        function extractCodeFromSegment(seg) {
    if (typeof seg !== 'string') return '';

    // 1) Bloc de code ‚Äú```‚Äù prioritaire
    const fence = seg.match(/```(?:[a-z-]+)?\s*([\s\S]*?)```/i);
    if (fence) return String(fence[1]).trim();

    // 2) Supprime les lignes "code", "html", "javascript", etc.
    const rows = seg.split(/\r?\n/).filter(l => {
        const t = String(l).trim();
        return !/^(code|html|xml|javascript|js|css|php|csharp|ts|typescript|json)$/i.test(t);
    });

    // 3) Retire les lignes vides en t√™te/queue
    let start = 0, end = rows.length;
    while (start < end && !String(rows[start]).trim()) start++;
    while (end > start && !String(rows[end - 1]).trim()) end--;

    // 4) Retourne tout le bloc tel quel
    return rows.slice(start, end).join('\n');
}

        function buildFlexibleRegexFrom(search) {
            const normalized = String(search).replace(/\r\n/g, '\n');
            const escaped = normalized
                .replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // √©chappe regex
                .replace(/\s+/g, '\\s+')                // espaces/newlines flexibles
                .replace(/["']/g, '["\']');             // tol√®re ' ou "
            try {
                return new RegExp(escaped, 'msu'); // m: multi-ligne, s: . traverse \n (s√©curit√©), u: unicode
            } catch {
                return null;
            }
        }

        function showStatus(type, msg) {
            cache.status.className = `status ${type}`;
            cache.status.textContent = msg;
        }

    </script>
</body>
</html>
